[{"title":"python学习-列表","url":"/2026/01/12/python%E5%AD%A6%E4%B9%A0-%E5%88%97%E8%A1%A8/","content":"list 列表基础1.列表基本样式：#其中可以是数字list_1 = [1,2,3,4,5,6]#其中也可以是字符串list_2 = [&#x27;str&#x27;,&#x27;banana&#x27;,&#x27;apple&#x27;]#其中也可以是混搭list_3 = [&#x27;orgin&#x27;,123]\n打印列表\nprint(list_1)\n显示为\n[1,2,3,4,5,6]\n\n2.访问列表中的元素按照顺序全部访问  for循环\nlist_1 = [1,2,3,4]for i in list_1:\tprint(i)\n\n使用下标索引访问其中的某一个元素\nlist_1 = [1,2,3,4,5]print(list_1[0])print(list_1[1])print(list_1[2])\n下标索引对应关系\n列表切片1.基础切片将原先的索引值改成一个范围即可实现切片\nlist_1 = [1,2,3,4,5]print(list_1[1:3]) #作弊右开区间  包头不含尾\n打印值：\n[2,3]\n2.从第一个开始切list_1 = [1,2,3,4,5]print(list_1[0:3])print(list_1[:3])\n3.切到最后一个list_1 = [1,2,3,4,5]print(list_1[1:5])print(list_1[1:])\n4.跳着切list_1 = [1,2,3,4,5]print(list_1[1:4:2]) #2是&#x27;步长&#x27;\n5.反着切list_1 = [1,2,3,4,5]print(list_1[：：-1]) #负号代表正负\n\n列表的增删改查在 Python 中，列表是可变的（Mutable），这意味着你可以随时修改它的内容。\n\n1. 增加元素 (Add)\nappend(obj)：在列表末尾添加一个元素。\ninsert(index, obj)：在指定索引位置插入元素，原位置及之后的元素后移。\nextend(iterable)：将另一个序列（列表、元组等）的内容合并到当前列表。\n\nlist_1 = [1, 2, 3]list_1.append(4)        # [1, 2, 3, 4]list_1.insert(1, &#x27;A&#x27;)   # [1, &#x27;A&#x27;, 2, 3, 4]list_1.extend([5, 6])   # [1, &#x27;A&#x27;, 2, 3, 4, 5, 6]\n\n2. 删除元素 (Delete)\ndel list[index]：根据索引删除（通用关键字）。\npop(index)：删除并返回指定索引的元素（不填索引默认删除最后一个）。\nremove(value)：删除列表中第一个匹配的值（如果有多个相同的值，只删第一个）。\nclear()：清空整个列表。\n\nlist_2 = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]list_2.remove(&#x27;banana&#x27;) # [&#x27;apple&#x27;, &#x27;cherry&#x27;]popped_item = list_2.pop(0)  # 返回 &#x27;apple&#x27;, 列表变为 [&#x27;cherry&#x27;]del list_2[0]           # []\n\n3. 修改元素 (Update)直接通过索引重新赋值即可。\nlist_3 = [10, 20, 30]list_3[1] = 200         # [10, 200, 30]\n\n4. 查找与统计 (Search)\nin &#x2F; not in：判断元素是否存在（返回布尔值 True&#x2F;False）。\nindex(value)：查找值的索引位置（如果值不存在会抛出 ValueError）。\ncount(value)：统计某个值在列表中出现的次数。\n\nlist_4 = [1, 2, 2, 3]print(2 in list_4)      # Trueprint(list_4.index(3))  # 3print(list_4.count(2))  # 2\n\n\n4. 排序与反转\nsort()：永久性排序（直接修改原列表）。\nsorted(list)：临时排序（不影响原列表，返回一个排序后的新列表）。\nreverse()：将列表中的元素反转。\n\nnums = [3, 1, 4, 2]nums.sort()              # nums 变为 [1, 2, 3, 4]nums.sort(reverse=True)  # 降序排列 [4, 3, 2, 1]original = [1, 3, 2]temp = sorted(original)  # temp 为 [1, 2, 3], original 仍为 [1, 3, 2]\n\n\n5. 进阶：列表推导式 (List Comprehension)这是 Python 中非常高效且优雅的工具，用于从旧列表快速生成新列表。\n基本语法： [表达式 for 变量 in 序列 if 条件]\n# 示例 1: 生成 1-10 的平方列表squares = [x**2 for x in range(1, 11)] # 输出: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# 示例 2: 过滤出列表中的偶数nums = [1, 2, 3, 4, 5, 6]evens = [x for x in nums if x % 2 == 0]# 输出: [2, 4, 6]\n\n\n6. 常用内置函数\n\n\n函数\n功能\n示例\n\n\n\nlen(list)\n获取列表长度（元素个数）\nlen([1,2]) -&gt; 2\n\n\nmax(list)\n获取列表中的最大值\nmax([1,5,2]) -&gt; 5\n\n\nmin(list)\n获取列表中的最小值\nmin([1,5,2]) -&gt; 1\n\n\nsum(list)\n获取列表元素总和（仅限数字）\nsum([1,2,3]) -&gt; 6\n\n\n","categories":["学习记录"],"tags":["Python"]},{"title":"生物信息之FASTA格式处理","url":"/2026/01/13/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E4%B9%8BFASTA%E6%A0%BC%E5%BC%8F%E5%A4%84%E7%90%86/","content":"1. 什么是 FASTA 格式？在生物信息学中，FASTA 是一种用于存储核酸序列或氨基酸序列的文本格式。它简单、通用，主要由两部分组成：\n\n标题行 (Header Line)：以大于号 &gt; 开头，包含序列的 ID 和描述信息。\n\n\n序列行 (Sequence Lines)：紧跟标题行之后的字符序列。需要注意的是，一条序列可能会分布在多个文本行中，这是初学者处理此类文件时最容易掉进去的“坑”。\n\n\n#用.strip()来去除后面的换行符（\\n）content = line.strip()\n\n\n2. Python 原生处理逻辑处理 FASTA 文件最核心的任务是：将多行序列合并，并与 ID 形成映射关系。我们通常使用 Python 的字典（Dictionary）来存储。\n核心代码实现以下代码展示了如何读取 dna.txt 并将其转换为字典格式：\nwith open(&#x27;dna.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f_dict = &#123;&#125;    seq_name = None    for line in f:        content = line.strip()  # 去除换行符和首尾空格        if content.startswith(&#x27;&gt;&#x27;):            # 遇到新序列的标题行，截取 ID 并初始化字典值            seq_name = content[1:]            f_dict[seq_name] = &#x27;&#x27;        else:            # 关键：如果不是标题行，则将序列追加到当前 ID 的值中            # 这样可以自动合并多行显示的序列            f_dict[seq_name] += content\n\n\n3. Rosalind 经典题目：计算最高 GC 含量题目背景：在 DNA 序列中，G 和 C 碱基所占的比例（GC-content）对于分析热稳定性及基因组结构至关重要。\n任务：给定若干条 FASTA 格式的序列，找出其中 GC 含量最高的一条，并输出其 ID 和百分比。\n\n\n算法思路\n解析文件：利用上述字典逻辑提取所有序列。\n统计频率：利用 count() 方法计算 G 和 C 的总和。\n比较排序：将结果存入列表并进行降序排列，取首位。\n\n完整解析代码compare = []# 遍历解析好的字典for name, seq in f_dict.items():    # 统计 G 和 C 的数量    gc_count = seq.count(&#x27;G&#x27;) + seq.count(&#x27;C&#x27;)    # 计算百分比    gc_content = (gc_count / len(seq)) * 100        # 将 (含量, ID) 作为元组存入列表，方便后续排序    compare.append((gc_content, name))    print(f&quot;DEBUG: &#123;name&#125; 的GC含量为: &#123;gc_content:.6f&#125;%&quot;)# 按 GC 含量从高到低排序compare.sort(reverse=True)# 获取结果max_gc_content, max_name = compare[0]print(&quot;-&quot; * 20)print(f&quot;最高 GC 含量序列 ID: &#123;max_name&#125;&quot;)print(f&quot;GC 含量: &#123;max_gc_content:.6f&#125;&quot;)\n\n\n4. 什么是 FASTQ 格式？在实际的测序下机数据中，我们更多看到的是 FASTQ 格式。它比 FASTA 多了两项内容：\n\n\n+ 标识符。\n质量值 (Quality Score)：对应每个碱基测序的准确度。\n\nFASTQ 逻辑结构（每 4 行为一个单位）：\n\nLine 1: @ 开头的 ID\nLine 2: 序列\nLine 3: +\nLine 4: 质量字符（如 IIIIHIIII...）\n\n\n5.完整代码with open(&#x27;dna.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f_dict = &#123;&#125;    seq_name = None    for line in f:        content = line.strip()        if content.startswith(&#x27;&gt;&#x27;):             seq_name = content[1:]            f_dict[seq_name] = &#x27;&#x27;        else:            f_dict[seq_name] += contentcompare = []print(f_dict)for name, seq in f_dict.items():    gc_count = seq.count(&#x27;G&#x27;) + seq.count(&#x27;C&#x27;)    gc_content = gc_count / len(seq) * 100    compare.append((gc_content, name))    print(f&quot;&#123;name&#125; 的GC含量为: &#123;gc_content&#125;%&quot;)compare.sort(reverse=True)max_gc_content, max_name = compare[0]print(f&quot; &#123;max_name&#125;\\n&#123;max_gc_content&#125;&quot;)\n\n\n\n","categories":["学习记录"],"tags":["Python","生物信息","学习"]},{"title":"齐鲁工大充电桩实时监控：从协议逆向到多线程自动化实战","url":"/2026/01/06/%E5%85%85%E7%94%B5%E6%A1%A9%E6%A3%80%E6%B5%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84/","content":"一、 项目背景齐鲁工业大学 23 号楼下的充电桩由威胜集团提供技术支持。由于官方小程序仅支持近距离扫码查看，无法远程获知全场 70 多个桩位的实时状态。在北方的严冬深夜，为了找一个空桩而在寒风中逐一尝试显然不是最优解。\n本项目旨在通过 Python 逆向监测，将全场状态聚合为一个实时更新的可视化看板。\n\n\n二、 协议逆向全流程1. 流量嗅探与抓包使用 Fiddler 对微信小程序进行 SSL 解密。通过分析发现，查询一个充电桩的状态需要遵循严格的顺序逻辑：\n\n第一步：Session 激活 (AddSession)告知服务器“我要查看某个桩”。如果跳过此步直接取数，后端会报错。\n第二步：数据拉取 (getWxInfo)服务器根据当前 Session 绑定的设备 ID，返回详细的 JSON 数据（包含剩余时间、占用状态等）。\n\n2. 身份凭证拆解接口校验的核心在于 Header 中的 Cookie：\n\nASP.NET_SessionId: 服务端生成的会话标识，具有时效性。\nOpenID: 用户在微信生态下的唯一标识。\n\n\n三、 核心架构设计1. 负载均衡与 Cookie 池由于单 Session 存在严重的频率限制，且极易因“操作频繁”被封禁。我设计了一个 Cookie 池 (Cookie Pool)。通过维护多个有效的 Session，系统可以利用多线程并发技术，将 70 个点位的查询压力平摊给多个“虚拟用户”。\n2. 关键代码片段A. 核心通信逻辑这是避开 .NET 后台 NullReferenceException 报错的关键。必须保证 Body 中的 openid 与 Cookie 严格一致。\ndef fetch_status(device_id, cookie, openid):    headers = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X)...&quot;,        &quot;Cookie&quot;: cookie,        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;    &#125;        # 1. 激活 Session 绑定    reg_url = &quot;[https://semiot.wasion.cn/Main/AddSession](https://semiot.wasion.cn/Main/AddSession)&quot;    requests.post(reg_url, headers=headers, data=&#123;&quot;AdminName&quot;: &quot;共享用电&quot;, &quot;DeviceNumber&quot;: device_id, &quot;PageTaype&quot;: &quot;1&quot;&#125;)    # 2. 拉取实时 JSON 报文    info_url = &quot;[https://semiot.wasion.cn/DeviceCurrentData/getWxInfo](https://semiot.wasion.cn/DeviceCurrentData/getWxInfo)&quot;    response = requests.post(info_url, headers=headers, data=&#123;&quot;DeviceNumber&quot;: device_id, &quot;openid&quot;: openid&#125;)        return response.json()\n\nB. 多线程任务调度使用 Queue 队列实现生产者-消费者模型。\ndef worker(cookie, task_queue):    while True:        pos, d_id = task_queue.get()        # 提取当前线程分配到的 OpenID        current_oid = extract_openid(cookie)                result = fetch_status(d_id, cookie, current_oid)        if result:            update_local_json(pos, result) # 线程安全写入                time.sleep(10) # 模拟人类操作间隔，保护 Session        task_queue.task_done()\n\n\n四、 坑位总结 (Post-Mortem)1. 致命的 500 错误现象：程序运行初期，频繁收到服务器返回的 HTML 错误页面，提示“未将对象引用设置到对象的实例”。分析：威胜后台代码鲁棒性不足。当 AddSession 与 getWxInfo 之间的调用间隔过短，或者 openid 参数大小写不敏感时，后端无法在内存中初始化用户对象。解决：严格对齐参数，并在两步操作间加入 0.5 秒的微小延迟。\n2. 动态 Session 过期现象：脚本运行数小时后，所有桩位显示“离线”。解决：编写了一个 Cookie Check 脚本。每隔一小时对池内 Cookie 进行“健康检查”，若失效则通过钉钉或企业微信机器人提醒手动更新抓包。\n五、伦理与安全性思考本项目的初衷是公共数据透明化，而非恶意攻击。在实现过程中，我严格限制了请求频率（单个 Cookie 间隔 10s 以上），确保不对官方服务器造成额外压力。\n\n六、 项目成果通过这套系统，全场 70 个充电桩的巡检周期从手工扫码（约 1 小时）缩短到了自动化轮询（约 3 分钟）。可视化看板不仅能显示哪个桩空着，还能通过 sytime 字段预测该桩位何时会释放，极大地优化了排队体验。\n\n技术栈： Python &#x2F; Flask &#x2F; Requests &#x2F; Fiddler &#x2F; Threading\n","categories":["开发日志"],"tags":["Python","爬虫","逆向工程","校园生活"]},{"title":"NumPy中的DNA序列：高效存储与计算指南","url":"/2026/01/17/Numpy%E4%B8%AD%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%EF%BC%881%EF%BC%89/","content":"NumPy中的DNA序列：高效存储与计算指南如果你是一位生物信息学爱好者，或者正在参与基因组研究项目，那么你一定知道NumPy是一个强大的工具。它不仅可以处理大量的数值数据，还可以很方便地处理字符串数据——特别是对于像DNA序列这样的生物数据来说，这简直是完美匹配！本文将带你了解在NumPy中存储和处理DNA序列的最佳实践，帮助你在Rosalind题目、基因组分析甚至更复杂的科研项目中事半功倍。\n为什么选择NumPy来处理DNA序列？传统的文本文件处理方式对于大型DNA序列来说效率低下，且难以进行高效的计算。而NumPy将DNA序列存储为数组，利用其强大的向量化运算能力，可以大幅提升计算速度和内存效率。\nNumPy中的DNA序列类型：各有所长1. NumPy 中的字符串存储方式NumPy 提供了多种字符串数据类型，每种类型都有其独特的特点和适用范围：\n\nU (Unicode)：每个字符占用 4 个字节。支持所有 Unicode 字符，包括中文、英文、表情符号等。这是最常用的字符串格式。\nS (Zero-terminated bytes)：类似于 UTF-8 或 ASCII。不支持中文（会报错或乱码），主要用于兼容旧的 C 语言数据。每个字符占用 1 个字节。\nobject: 万能容器，可以存储任何 Python 对象，包括字符串。不限制长度，不会截断。但速度慢，内存占用大。\n\n2. DNA 序列处理：选择最佳“ dtype”针对 DNA 序列（仅包含 A、C、G、T），我们应该优先考虑以下两种格式：\n\nS1 (字节数组)\n：每个碱基占用1 个字节。\n\n优点：节省内存，计算速度快。尤其适合处理大规模基因组数据或大量短序列（Read 序列）。\n适用场景：Rosalind 题目、基因组分析等。\n\n\nnp.uint8 (数值映射)\n：将 A、C、G、T 映射为 0、1、2、3（或它们的 ASCII 码）。\n\n优点：计算速度极快，可以利用位运算进行高效计算。\n适用场景：需要频繁计算碱基频率（例如 GC 含量）的场合。\n\n\n\n如何选择最佳的DNA序列类型？\n\n\n场景\n推荐格式\n每个碱基占用内存\n优点\n缺点\n性能\n\n\n\n大规模基因组分析\nuint8\n1 Byte\n计算速度快，节省大量内存\n无法直接像字符串一样操作\n极高\n\n\n标准 Rosalind 练习\n&#39;S1&#39;\n1 Byte\n兼顾易读性和内存效率\n\n高\n\n\n简单的练习&#x2F;小数据\nstr\n随 Python\n操作简单，无需特殊处理\n计算速度慢，内存消耗大\n中等\n\n\n混合长度&#x2F;复杂文本\nobject\n较大\n灵活的操作方式，可以进行字符串中间插入\n牺牲了NumPy的并行计算优势\n低\n\n\n代码示例与最佳实践\n使用 S1 计算 GC 含量（Rosalind题目）：\n\nimport numpy as npsequence = &quot;GATTACA&quot;dna_numeric = np.frombuffer(sequence.encode(), dtype=np.uint8)gc_count = np.sum(dna_numeric == 2 | dna_numeric == 3)  # G (2) or C (3)gc_percentage = (gc_count / len(dna_numeric)) * 100print(f&quot;GC含量：&#123;gc_percentage:.2f&#125;%&quot;)\n\n\n使用uint8存储并计算长度:\n\nimport numpy as npsequence = &quot;GATTACA&quot;dna = np.array(list(sequence), dtype=np.uint8) # 将字符串转换为数值数组print (len(dna))  # 打印数组的长度\n\n总结：选择最适合你的DNA序列存储方式在NumPy中处理DNA序列时，没有绝对的最佳方案。你需要根据具体场景和需求来权衡不同的数据类型。对于大型基因组分析，uint8 或 S1 是首选；对于简单的练习或小数据集，U 也是一个不错的选择。\n","categories":["学习记录","Numpy中的生物学"],"tags":["Python","生物信息","学习","Numpy","数据处理"]}]